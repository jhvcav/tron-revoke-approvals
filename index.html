<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R√©vocation d'Approbations TRC20</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tronweb/4.4.0/TronWeb.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .status-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .wallet-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border-left: 5px solid #667eea;
        }
        
        .wallet-section h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        
        .wallet-section h3::before {
            content: "üîó";
            margin-right: 10px;
            font-size: 1.2em;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
        }
        
        .input-group input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.2);
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px 10px 10px 0;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        
        .btn-danger:hover {
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
        }
        
        .approvals-list {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-top: 25px;
        }
        
        .approval-item {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .approval-item:hover {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }
        
        .approval-info {
            flex: 1;
        }
        
        .contract-address {
            font-family: 'Courier New', monospace;
            background: #f1f3f4;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .allowance {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .alert {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .alert-error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîí R√©vocation d'Approbations TRC20</h1>
            <p>G√©rez et r√©voquez vos approbations de smart contracts sur le r√©seau Tron</p>
        </div>
        
        <div class="status-card">
            <div id="connectionStatus">
                <strong>√âtat de la connexion :</strong> <span id="statusText">D√©connect√©</span>
            </div>
        </div>
        
        <div class="wallet-section">
            <h3>Connexion du Wallet</h3>
            <button id="connectBtn" class="btn">Se connecter avec TronLink</button>
            <div id="walletInfo" style="display: none;">
                <div class="input-group">
                    <label>Adresse du wallet :</label>
                    <input type="text" id="walletAddress" readonly>
                </div>
                <div class="input-group">
                    <label>Balance TRX :</label>
                    <input type="text" id="trxBalance" readonly>
                </div>
            </div>
        </div>
        
        <div class="wallet-section">
            <h3>Token √† v√©rifier</h3>
            <div class="input-group">
                <label>Adresse du contrat TRC20 (USDT par d√©faut) :</label>
                <input type="text" id="tokenAddress" value="TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" placeholder="Adresse du contrat TRC20">
            </div>
            <div class="alert alert-warning">
                <strong>Note :</strong> L'adresse par d√©faut est celle de l'USDT sur Tron. Vous pouvez la modifier pour d'autres tokens TRC20.
            </div>
            <button id="checkApprovalsBtn" class="btn" disabled>V√©rifier les Approbations (Auto)</button>
        </div>
        
        <div class="wallet-section">
            <h3>R√©vocation manuelle</h3>
            <div class="input-group">
                <label>Adresse du contrat √† r√©voquer (si vous la connaissez) :</label>
                <input type="text" id="manualContractAddress" placeholder="Collez l'adresse du contrat depuis Tronscan">
            </div>
            <div class="input-group">
                <label>Adresse du token (m√™me que ci-dessus) :</label>
                <input type="text" id="manualTokenAddress" value="TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" placeholder="Adresse du token">
            </div>
            <div class="alert alert-warning">
                <strong>Mode manuel :</strong> Si l'auto-d√©tection ne fonctionne pas, copiez l'adresse du contrat depuis Tronscan et utilisez cette section.
            </div>
            <button id="manualRevokeBtn" class="btn btn-danger" disabled>R√©voquer Manuellement</button>
            <button id="checkAllowanceBtn" class="btn" disabled style="background: #28a745;">V√©rifier l'Allowance</button>
            <button id="diagnosticBtn" class="btn" disabled style="background: #17a2b8;">Diagnostic Avanc√©</button>
        </div>
        
        <div class="wallet-section">
            <h3>üîç Diagnostic et alternatives</h3>
            <div class="input-group">
                <label>Adresse exacte depuis Tronscan (avec espaces/caract√®res sp√©ciaux) :</label>
                <input type="text" id="rawContractAddress" placeholder="Collez exactement ce que vous voyez sur Tronscan">
            </div>
            <button id="cleanAddressBtn" class="btn" disabled style="background: #ffc107; color: black;">Nettoyer l'adresse</button>
            <button id="forceRevokeBtn" class="btn btn-danger" disabled>Forcer la r√©vocation</button>
        </div>
        
        <div id="loadingSection" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p>Chargement des approbations...</p>
        </div>
        
        <div id="approvalsSection" class="approvals-list" style="display: none;">
            <h3>üìã Approbations Actives</h3>
            <div id="approvalsList"></div>
        </div>
        
        <div id="alertsContainer"></div>
    </div>

    <script>
        class TronApprovalManager {
            constructor() {
                this.tronWeb = null;
                this.userAddress = null;
                this.init();
            }
            
            init() {
                this.bindEvents();
                this.checkTronLink();
            }
            
            bindEvents() {
                document.getElementById('connectBtn').addEventListener('click', () => this.connectWallet());
                document.getElementById('checkApprovalsBtn').addEventListener('click', () => this.checkApprovals());
                document.getElementById('manualRevokeBtn').addEventListener('click', () => this.manualRevoke());
                document.getElementById('checkAllowanceBtn').addEventListener('click', () => this.checkAllowance());
                document.getElementById('diagnosticBtn').addEventListener('click', () => this.runDiagnostic());
                document.getElementById('cleanAddressBtn').addEventListener('click', () => this.cleanAddress());
                document.getElementById('forceRevokeBtn').addEventListener('click', () => this.forceRevoke());
            }
            
            async checkTronLink() {
                if (window.tronWeb && window.tronWeb.ready) {
                    this.showAlert('TronLink d√©tect√© et pr√™t', 'success');
                } else {
                    this.showAlert('TronLink non d√©tect√©. Veuillez installer TronLink pour continuer.', 'error');
                }
            }
            
            async connectWallet() {
                try {
                    if (!window.tronWeb) {
                        throw new Error('TronLink n\'est pas install√©');
                    }
                    
                    if (!window.tronWeb.ready) {
                        await this.waitForTronWeb();
                    }
                    
                    this.tronWeb = window.tronWeb;
                    this.userAddress = this.tronWeb.defaultAddress.base58;
                    
                    if (!this.userAddress) {
                        throw new Error('Adresse du wallet non disponible');
                    }
                    
                    const balance = await this.tronWeb.trx.getBalance(this.userAddress);
                    const trxBalance = this.tronWeb.fromSun(balance);
                    
                    document.getElementById('walletAddress').value = this.userAddress;
                    document.getElementById('trxBalance').value = `${trxBalance} TRX`;
                    document.getElementById('walletInfo').style.display = 'block';
                    document.getElementById('connectBtn').style.display = 'none';
                    document.getElementById('checkApprovalsBtn').disabled = false;
                    document.getElementById('manualRevokeBtn').disabled = false;
                    document.getElementById('checkAllowanceBtn').disabled = false;
                    document.getElementById('diagnosticBtn').disabled = false;
                    document.getElementById('cleanAddressBtn').disabled = false;
                    document.getElementById('forceRevokeBtn').disabled = false;
                    document.getElementById('statusText').textContent = 'Connect√©';
                    
                    this.showAlert('Wallet connect√© avec succ√®s!', 'success');
                } catch (error) {
                    this.showAlert(`Erreur de connexion: ${error.message}`, 'error');
                }
            }
            
            waitForTronWeb() {
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 30;
                    
                    const check = () => {
                        if (window.tronWeb && window.tronWeb.ready) {
                            resolve();
                        } else if (attempts < maxAttempts) {
                            attempts++;
                            setTimeout(check, 1000);
                        } else {
                            reject(new Error('TronLink n\'est pas pr√™t'));
                        }
                    };
                    check();
                });
            }
            
            async checkApprovals() {
                const tokenAddress = document.getElementById('tokenAddress').value.trim();
                if (!tokenAddress) {
                    this.showAlert('Veuillez entrer l\'adresse du token', 'error');
                    return;
                }
                
                document.getElementById('loadingSection').style.display = 'block';
                document.getElementById('approvalsSection').style.display = 'none';
                
                try {
                    this.showAlert('Recherche des approbations via les √©v√©nements...', 'warning');
                    
                    // M√©thode 1: √âv√©nements d'approbation
                    const approvals = await this.getApprovalEvents(tokenAddress);
                    
                    // M√©thode 2: V√©rification directe via TronGrid API
                    if (approvals.length === 0) {
                        this.showAlert('Aucun √©v√©nement trouv√©, tentative via TronGrid...', 'warning');
                        const tronGridApprovals = await this.getApprovalsTronGrid(tokenAddress);
                        approvals.push(...tronGridApprovals);
                    }
                    
                    document.getElementById('loadingSection').style.display = 'none';
                    
                    if (approvals.length > 0) {
                        this.displayApprovals(approvals, null);
                        document.getElementById('approvalsSection').style.display = 'block';
                        this.showAlert(`${approvals.length} approbation(s) trouv√©e(s)`, 'success');
                    } else {
                        this.showAlert('Aucune approbation active trouv√©e avec la d√©tection automatique. Essayez la m√©thode manuelle si vous en voyez sur Tronscan.', 'warning');
                    }
                } catch (error) {
                    document.getElementById('loadingSection').style.display = 'none';
                    this.showAlert(`Erreur lors de la v√©rification: ${error.message}`, 'error');
                }
            }
            
            async getApprovalsTronGrid(tokenAddress) {
                try {
                    // Utiliser l'API TronGrid pour obtenir les transactions
                    const response = await fetch(`https://api.trongrid.io/v1/accounts/${this.userAddress}/transactions/trc20?limit=200&contract_address=${tokenAddress}`);
                    const data = await response.json();
                    
                    const approvals = [];
                    
                    if (data.data) {
                        // Analyser les transactions pour trouver les approbations
                        for (const tx of data.data) {
                            if (tx.type === 'Transfer' && tx.token_info && tx.token_info.address === tokenAddress) {
                                // V√©rifier si c'est une approbation en regardant les contrats impliqu√©s
                                if (tx.to !== this.userAddress && tx.from === this.userAddress) {
                                    // Potentielle approbation
                                    approvals.push({
                                        spender: tx.to,
                                        value: tx.value,
                                        timestamp: tx.block_timestamp,
                                        transactionId: tx.transaction_id
                                    });
                                }
                            }
                        }
                    }
                    
                    return approvals;
                } catch (error) {
                    console.error('Erreur TronGrid:', error);
                    return [];
                }
            }
            
            async checkAllowance() {
                const tokenAddress = document.getElementById('manualTokenAddress').value.trim();
                const spenderAddress = document.getElementById('manualContractAddress').value.trim();
                
                if (!tokenAddress || !spenderAddress) {
                    this.showAlert('Veuillez remplir les deux adresses', 'error');
                    return;
                }
                
                try {
                    const contract = await this.tronWeb.contract().at(tokenAddress);
                    const allowance = await contract.allowance(this.userAddress, spenderAddress).call();
                    
                    const formatted = this.formatTokenAmount(allowance.toString());
                    
                    if (allowance && allowance.toString() !== '0') {
                        this.showAlert(`Allowance trouv√©e: ${formatted} tokens approuv√©s pour ce contrat`, 'warning');
                    } else {
                        this.showAlert('Aucune allowance trouv√©e pour ce contrat', 'success');
                    }
                } catch (error) {
                    this.showAlert(`Erreur lors de la v√©rification: ${error.message}`, 'error');
                }
            }
            
            async manualRevoke() {
                const tokenAddress = document.getElementById('manualTokenAddress').value.trim();
                const spenderAddress = document.getElementById('manualContractAddress').value.trim();
                
                if (!tokenAddress || !spenderAddress) {
                    this.showAlert('Veuillez remplir les deux adresses', 'error');
                    return;
                }
                
                try {
                    this.showAlert('R√©vocation manuelle en cours...', 'warning');
                    
                    const contract = await this.tronWeb.contract().at(tokenAddress);
                    
                    // V√©rifier d'abord l'allowance
                    const allowance = await contract.allowance(this.userAddress, spenderAddress).call();
                    
                    if (!allowance || allowance.toString() === '0') {
                        this.showAlert('Aucune approbation trouv√©e pour ce contrat', 'warning');
                        return;
                    }
                    
                    // Proc√©der √† la r√©vocation
                    const transaction = await contract.approve(spenderAddress, 0).send({
                        feeLimit: 100000000,
                        from: this.userAddress
                    });
                    
                    this.showAlert(`R√©vocation manuelle r√©ussie! Transaction ID: ${transaction}`, 'success');
                    
                    // V√©rifier √† nouveau apr√®s 3 secondes
                    setTimeout(() => {
                        this.checkAllowance();
                    }, 3000);
                    
                } catch (error) {
                    this.showAlert(`Erreur lors de la r√©vocation manuelle: ${error.message}`, 'error');
                }
            }
            
            async runDiagnostic() {
                const tokenAddress = document.getElementById('manualTokenAddress').value.trim();
                const spenderAddress = document.getElementById('manualContractAddress').value.trim();
                
                if (!tokenAddress || !spenderAddress) {
                    this.showAlert('Veuillez remplir les deux adresses', 'error');
                    return;
                }
                
                this.showAlert('Diagnostic en cours...', 'warning');
                
                try {
                    // Test 1: Validation des adresses
                    const isValidToken = this.tronWeb.isAddress(tokenAddress);
                    const isValidSpender = this.tronWeb.isAddress(spenderAddress);
                    
                    this.showAlert(`Adresse token valide: ${isValidToken}, Adresse spender valide: ${isValidSpender}`, 'warning');
                    
                    if (!isValidToken || !isValidSpender) {
                        this.showAlert('Une des adresses n\'est pas valide', 'error');
                        return;
                    }
                    
                    // Test 2: Conversion hex/base58
                    const tokenHex = this.tronWeb.address.toHex(tokenAddress);
                    const spenderHex = this.tronWeb.address.toHex(spenderAddress);
                    
                    this.showAlert(`Token (hex): ${tokenHex}`, 'warning');
                    this.showAlert(`Spender (hex): ${spenderHex}`, 'warning');
                    
                    // Test 3: Appel direct √† la blockchain
                    const contract = await this.tronWeb.contract().at(tokenAddress);
                    
                    // Test 4: V√©rifier que le contrat est bien un TRC20
                    try {
                        const name = await contract.name().call();
                        const symbol = await contract.symbol().call();
                        this.showAlert(`Token trouv√©: ${name} (${symbol})`, 'success');
                    } catch (e) {
                        this.showAlert('Erreur: Ce n\'est peut-√™tre pas un contrat TRC20 valide', 'error');
                    }
                    
                    // Test 5: Allowance avec diff√©rentes m√©thodes
                    try {
                        const allowance1 = await contract.allowance(this.userAddress, spenderAddress).call();
                        this.showAlert(`Allowance (m√©thode 1): ${allowance1}`, 'warning');
                        
                        // Essai avec adresses hex
                        const allowance2 = await contract.allowance(
                            this.tronWeb.address.toHex(this.userAddress), 
                            this.tronWeb.address.toHex(spenderAddress)
                        ).call();
                        this.showAlert(`Allowance (m√©thode 2 - hex): ${allowance2}`, 'warning');
                        
                    } catch (e) {
                        this.showAlert(`Erreur allowance: ${e.message}`, 'error');
                    }
                    
                    // Test 6: Recherche via API alternative
                    try {
                        const apiResponse = await fetch(`https://apilist.tronscanapi.com/api/account/tokens?address=${this.userAddress}&start=0&limit=50&token=${tokenAddress}`);
                        const apiData = await apiResponse.json();
                        this.showAlert(`Donn√©es API Tronscan: ${JSON.stringify(apiData.data?.slice(0,2) || 'Aucune donn√©e')}`, 'warning');
                    } catch (e) {
                        this.showAlert('API Tronscan non accessible', 'warning');
                    }
                    
                } catch (error) {
                    this.showAlert(`Erreur diagnostic: ${error.message}`, 'error');
                }
            }
            
            cleanAddress() {
                const rawAddress = document.getElementById('rawContractAddress').value;
                
                if (!rawAddress) {
                    this.showAlert('Veuillez entrer l\'adresse brute', 'error');
                    return;
                }
                
                // Nettoyer l'adresse: supprimer espaces, caract√®res invisibles, etc.
                let cleaned = rawAddress.replace(/[\s\u200B-\u200D\uFEFF]/g, '');
                
                // Extraire seulement la partie qui ressemble √† une adresse Tron
                const tronAddressMatch = cleaned.match(/T[A-Za-z0-9]{33}/);
                
                if (tronAddressMatch) {
                    cleaned = tronAddressMatch[0];
                    document.getElementById('manualContractAddress').value = cleaned;
                    this.showAlert(`Adresse nettoy√©e: ${cleaned}`, 'success');
                } else {
                    this.showAlert('Aucune adresse Tron valide trouv√©e dans le texte', 'error');
                }
            }
            
            async forceRevoke() {
                const tokenAddress = document.getElementById('manualTokenAddress').value.trim();
                const spenderAddress = document.getElementById('manualContractAddress').value.trim();
                
                if (!tokenAddress || !spenderAddress) {
                    this.showAlert('Veuillez remplir les deux adresses', 'error');
                    return;
                }
                
                try {
                    this.showAlert('FORCE: Tentative de r√©vocation m√™me sans allowance d√©tect√©e...', 'warning');
                    
                    const contract = await this.tronWeb.contract().at(tokenAddress);
                    
                    // Forcer la r√©vocation sans v√©rification pr√©alable
                    const transaction = await contract.approve(spenderAddress, 0).send({
                        feeLimit: 150000000, // Augmenter la limite
                        from: this.userAddress
                    });
                    
                    this.showAlert(`FORCE: Transaction envoy√©e! ID: ${transaction}`, 'success');
                    this.showAlert('V√©rifiez Tronscan dans quelques minutes pour confirmer', 'warning');
                    
                } catch (error) {
                    this.showAlert(`Erreur force: ${error.message}`, 'error');
                }
            }
            
            async getApprovalEvents(tokenAddress) {
                try {
                    // Cette m√©thode utilise l'API Tron pour obtenir les √©v√©nements
                    const response = await fetch(`https://api.trongrid.io/v1/contracts/${tokenAddress}/events?event_name=Approval&only_confirmed=true&limit=200`);
                    const data = await response.json();
                    
                    if (!data.data) return [];
                    
                    // Filtrer les √©v√©nements pour l'utilisateur actuel
                    const userApprovals = data.data.filter(event => {
                        const owner = this.tronWeb.address.fromHex(event.result.owner);
                        return owner === this.userAddress;
                    });
                    
                    // Grouper par spender et garder le plus r√©cent
                    const approvalMap = new Map();
                    
                    userApprovals.forEach(event => {
                        const spender = this.tronWeb.address.fromHex(event.result.spender);
                        const value = event.result.value;
                        const timestamp = event.block_timestamp;
                        
                        if (!approvalMap.has(spender) || approvalMap.get(spender).timestamp < timestamp) {
                            approvalMap.set(spender, {
                                spender: spender,
                                value: value,
                                timestamp: timestamp,
                                transactionId: event.transaction_id
                            });
                        }
                    });
                    
                    // Filtrer les approbations avec une valeur > 0
                    return Array.from(approvalMap.values()).filter(approval => 
                        approval.value && approval.value !== '0'
                    );
                } catch (error) {
                    console.error('Erreur lors de la r√©cup√©ration des √©v√©nements:', error);
                    return [];
                }
            }
            
            displayApprovals(approvals, contract) {
                const container = document.getElementById('approvalsList');
                container.innerHTML = '';
                
                if (approvals.length === 0) {
                    container.innerHTML = '<p>Aucune approbation active trouv√©e.</p>';
                    return;
                }
                
                approvals.forEach((approval, index) => {
                    const approvalDiv = document.createElement('div');
                    approvalDiv.className = 'approval-item';
                    
                    const allowanceFormatted = this.formatTokenAmount(approval.value);
                    const dateFormatted = new Date(approval.timestamp).toLocaleString('fr-FR');
                    
                    approvalDiv.innerHTML = `
                        <div class="approval-info">
                            <h4>Contract approuv√© #${index + 1}</h4>
                            <div class="contract-address">${approval.spender}</div>
                            <div class="allowance">Montant approuv√©: ${allowanceFormatted}</div>
                            <div class="allowance">Date: ${dateFormatted}</div>
                        </div>
                        <div>
                            <button class="btn btn-danger" onclick="approvalManager.revokeApproval('${approval.spender}', ${index})">
                                R√©voquer
                            </button>
                        </div>
                    `;
                    
                    container.appendChild(approvalDiv);
                });
            }
            
            formatTokenAmount(value) {
                if (!value || value === '0') return '0';
                
                // Pour USDT (6 d√©cimales)
                const decimals = 6;
                const amount = this.tronWeb.toBigNumber(value).dividedBy(Math.pow(10, decimals));
                
                if (amount.isGreaterThan(1000000000000)) {
                    return 'Illimit√©';
                }
                
                return amount.toFixed(2);
            }
            
            async revokeApproval(spenderAddress, index) {
                const tokenAddress = document.getElementById('tokenAddress').value.trim();
                
                try {
                    this.showAlert('R√©vocation en cours...', 'warning');
                    
                    // Cr√©er une instance du contrat
                    const contract = await this.tronWeb.contract().at(tokenAddress);
                    
                    // Appeler la fonction approve avec 0 pour r√©voquer
                    const transaction = await contract.approve(spenderAddress, 0).send({
                        feeLimit: 100000000, // 100 TRX de limite
                        from: this.userAddress
                    });
                    
                    this.showAlert(`R√©vocation r√©ussie! Transaction ID: ${transaction}`, 'success');
                    
                    // Recharger les approbations apr√®s un d√©lai
                    setTimeout(() => {
                        this.checkApprovals();
                    }, 3000);
                    
                } catch (error) {
                    this.showAlert(`Erreur lors de la r√©vocation: ${error.message}`, 'error');
                }
            }
            
            showAlert(message, type) {
                const container = document.getElementById('alertsContainer');
                const alert = document.createElement('div');
                alert.className = `alert alert-${type}`;
                alert.innerHTML = message;
                
                container.appendChild(alert);
                
                // Supprimer l'alerte apr√®s 5 secondes
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.parentNode.removeChild(alert);
                    }
                }, 5000);
            }
        }
        
        // Initialiser l'application
        const approvalManager = new TronApprovalManager();
    </script>
</body>
</html>
